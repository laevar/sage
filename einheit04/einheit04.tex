\documentclass[notes=hide,hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Sage - Einheit 4}
\subtitle{Matrizen, Vektorräume, Programmieren I}
\input{../slide_header}
\maketitle

\begin{frame}{Aufbau}
\tableofcontents
\end{frame}

% \begin{frame}{Übersicht}
% \begin{itemize}
% \item Vektoren
% \item Vektorräume
% \item Lineare Unabhängigkeit, Basis
% \item Matrizen
% \item MuPAD-Bibliotheken
% \item Ein erstes Programm
% \end{itemize}
% \end{frame}

%===================================================
\section{Vektoren}
%==================================================
\subsection{Matrizen}

\begin{frame}{Matrizen}
Eine {\color{red} $m \times n$ Matrix} $A$ über einen Körper $K$ ist ein rechteckiges
Schema mit Einträgen $a_{ij} \in K$, $ 1 \leq i \leq m$, $1 \leq j
\leq n$  der Form
\[ A = \left( \begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn} 
\end{array} \right) \] 
mit dem Zeilenindex $i$ mit Werten zwischen $1$ und $m$ und
Spaltenindex $j$ mit Werten zwischen $1$ und $n$. Man schreibt kurz
$A=(a_{ij}) \in K^{m\times n}$. 
\end{frame}

\begin{frame}{Definitionen}
\begin{itemize}
\item Die {\color{red} Transponierte } von $A=(a_{ij})$ ist $A^T:=(a_{ji})$.
\item $A$ heißt {\color{red} symmetrisch}, wenn $A=A^T$ gilt.
\item Für Matrizen $A=(a_{ij})\in \mathbb{C}^{m\times n}$ ist $A^* :=
(\overline{a_{ji}}) \in \mathbb{C}^{n \times m}$.
\item Die {\color{red} Einheitsmatrix} $I:=I_n:=(\delta_{ij}) \in K^{n \times
n}$
\item Seien $A=(a_{ij}),B=(b_{ij}) \in {K}^{n \times m}$. Dann ist die {\color{red} Addition}
definiert durch 
\[ C=(c_{ij}):=A+B \in {K}^{n \times m} \]
mit $c_{ij}=a_{ij}+b_{ij}$.  
\end{itemize}
\end{frame} 

\begin{frame}{Definitionen}
\begin{itemize}
\item Seien $A=(a_{ij}) \in {K}^{m \times n}$ und $B=(b_{ij})
\in {K}^{n \times p}$. Dann ist die {\color{red} Multiplikation}
gegeben durch  
\[ C=(c_{ij}):=A \cdot B \in{K}^{m \times p} \]
mit $c_{ij}=\sum_{k=1}^n a_{ik} b_{kj}$. 
\item $A\in K^{n \times n}$ heißt {\color{red} orthogonal}, wenn $A \cdot
A^T=A^T \cdot A=I_n$ gilt.
\item $A\in \mathbb{C}^{n \times n}$ heißt {\color{red} unitär}, wenn $A \cdot
A^*=A^* \cdot A=I_n$ gilt.
\item $A\in K^{n \times n}$ heißt {\color{red} invertierbar}, wenn eine
Matrix $A^{-1}\in K^{n \times n}$ existiert mit  $A \cdot
A^{-1}=A^{-1} \cdot A=I_n$.
\end{itemize}
\end{frame} 

\begin{frame}{Definitionen und Bemerkungen}
\begin{itemize}
\item Die Multiplikation ist assoziativ aber in der Regel \alert{nicht kommutativ}. 
\item Die Matrizen aus $K^{m \times n}$ bilden einen Vektorraum über
$K$ (mit komponentenweiser Skalarmultiplikation).
\item Die Menge der invertierbaren Matrizen aus $K^{n \times n}$
bilden bezüglich der Multiplikation eine Gruppe, die {\color{red} allgemeine
lineare Gruppe} $\operatorname{GL}(K,n) = \operatorname{GL}_n(K) = \operatorname{GL}(n,K)$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Definition und Bemerkungen}
\begin{itemize}
\item Die Menge der orthogonalen Matrizen in $GL(\mathbb{R},n)$ bilden
 eine Untergruppe von  $GL(\mathbb{R},n)$, die {\color{red} orthogonale
 Gruppe} $O(n)$. 

\item Die entsprechende Untergruppe der unitären Matrizen
 in $GL(\mathbb{C},n)$ ist die {\color{red} unitäre Gruppe} $U(n)$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Matrizen in Sage}
\begin{itemize}
\item Matrizen werden in Sage mit Hilfe des Befehls \isage{matrix()}
konstruiert. 
\item Der Rückgabewert ist vom Typ \isage{matrix}.
\item Die Einträge der Matrix können beliebige Ausdrücke sein.
\item Es ist auch möglich Matrizen über bestimmten Bereichen
(z.B. $\mathbb{R}$, $\mathbb{C}$, $\mathbb{Z}$) zu
konstruieren. 
\item Es gibt auch spezielle Datenstrukturen für quadratische Matrizen
und für dünnbesetzte Matrizen. 
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Konstruktion von Matrizen I}
Es gibt in Sage verschiedene Möglichkeiten eine Matrix zu
konstruieren. Beispiel:
\[ A:= \left( \begin{array}{cccc}
1 & 2 & 3 & 4\\
a & 0 & 1 & b\\ 
\end{array} \right), \quad a,b\in \mathbb{R} \]
\begin{itemize}
\item Eingabe der Einträge pro Zeile in eckigen Klammern $[ ..]$. Alle
Spalten dann wieder in eckigen Klammern $[ ..]$.
\begin{sagein}
A = matrix([[1, 2, 3, 4],[a, 0, 1, b]]) 
\end{sagein}
\item Mit expliziter Größenangabe
\begin{sagein}
A = matrix(2,4,[[1,2,3,4],[a,0,1,b]]) 
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Konstruktion von Matrizen II}
\begin{itemize}
\item Erzeugen einer Nullmatrix der Größe $n \times m$
\begin{sagein}
n = 3; m = 4; B = matrix(n,m)
\end{sagein}
\item Erzeuge eine $n \times m$ - Matrix $A$ mit Hilfe einer Funktion
$f(i,j)$ mit Einträgen $a_{ij}=f(i,j)$
\begin{sagein}
f(i,j) = i*j
C = matrix([[f(i,j) for i in range(1,6)] for j in range(1,4)]); C
\end{sagein}
\item Eingabe von Zeilen- und Spaltenvektoren (falls explizit nötig)
\begin{sagein}
matrix(3,1,[1,2,3])
matrix(1,3,[4,5,6])
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zeilen- und Spaltenzahl}
\begin{itemize}
\item Abfragen der Spaltenanzahl: \isage{<matrix>.ncols()}
\begin{sagein}
C.ncols()
\end{sagein}
\begin{sage}
  5
\end{sage}
\item Abfragen der Zeilenanzahl: \isage{<matrix>.nrows()}
\begin{sagein}
C.nrows()
\end{sagein}
\begin{sage}
  3
\end{sage}
\item Informationen über die Matrix: \isage{<matrix>.parent()}
\begin{sagein}
C.parent()
\end{sagein}
\begin{sage}
Full MatrixSpace of 3 by 5 dense matrices over Symbolic Ring
\end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zugriff auf die Einträge I}
\begin{itemize}
\item Abfragen von Einträgen in Zeile $i$ und Spalte $j$:
\begin{sagein}
i=1; j=2; C[i,j]
\end{sagein}
\begin{sage}
  6
\end{sage}
\item Ändern des Eintrags in Zeile $i$ und Spalte $j$:
\begin{sagein}
i=1; j=2; C[i,j]=22
\end{sagein}
\item Extrahieren von Zeilen/Spalten
\begin{sagein}
zeile = C.row(0)
spalte = C.column(4)
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zugriff auf die Einträge II}
\begin{itemize}
\item Extrahieren von Teilmatrizen
\begin{sagein}
C[1:3,1:3]
\end{sagein}
\item Erzeugen von Diagonalmatrizen
\begin{sagein}
x = [1,2,3,4,5]
Diag = diagonal_matrix(x); Diag
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Rechnen mit Matrizen}
\begin{itemize} 
\item Addieren, Multiplizieren
\begin{sagein}
var('a,b,c,d,g,h,f')
A = matrix([[a, b], [c,d]])
B = matrix([[e, f], [g,h]])
A+B; A*B
\end{sagein}
\item Bestimmung der Inversen und der Transponierten
\begin{sagein}
A^(-1); A.transpose()
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}{Rang von Matrizen}
Sei $A \in K^{m \times n}$. 
\begin{itemize}
\item Die Dimension der linearen Hülle der Spaltenvektoren nennt man
den {\color{red} Spaltenrang} von $A$. Er ist höchstens gleich $n$.
\item Die Dimension der linearen Hülle der Zeilenvektoren nennt man den
{\color{red} Zeilenrang} von $A$. Er ist höchstens gleich $m$.
\item Zeilenrang und Spaltenrang von Matrizen sind gleich und man
spricht deshalb vom {\color{red} Rang} einer Matrix. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Matrizen}
\begin{itemize}
\item Bestimmen des Ranges einer Matrix
\begin{sagein}
S = matrix([[1,0,0],[0,1,1],[1,1,1]])
S.rank()
\end{sagein}
\begin{sage}
  2
\end{sage}
\item ist S symmetrisch ? ist S invertierbar ?
\begin{sagein}
S.is_symmetric() 
S.is_invertible()
\end{sagein}
\begin{sage}
False
False
\end{sage}
% \item Ist eine Matrix unitär ?
% \begin{sagein}
% linalg::isUnitary(S)
% \end{sagein}
% \begin{sage}
%   FALSE
% \end{sage}
% \begin{sagein}
% F:=matrix([[I,0],[0,-I]])
% linalg::isUnitary(F)
% \end{sagein}
% \begin{sage}
%   TRUE
% \end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Maps auf Matrizen}
Mittels \isage{map_threaded(<function>,<matrix>)} kann auf jeden Eintrag von der Matrix \isage{<matrix>} die Funktion \isage{<function>} angewendet werden (wie bei \isage{map()})\\
Beispiel:
\begin{sagein}
map_threaded(sqrt,matrix(RR,[[1,2],[3,4]]))
\end{sagein}
  	
\begin{sage}
[1.00000000000000 1.41421356237310]
[1.73205080756888 2.00000000000000] 
\end{sage}

\end{frame}





\subsection{Vektorräume}
\begin{frame}{Vektorraum}
Ein Tripel $(V,+,\cdot)$, bestehend aus einer nichtleeren Menge $V$
und Verknüpfungen
\[ +:V \times V \ \rightarrow \ V, \qquad \cdot:K\times V \ \rightarrow \ V\]
heißt {\color{red} Vektorraum} über einem Körper
$K$, wenn gilt:
\begin{enumerate}
\item $(V,+)$ ist eine abelsche Gruppe.
\item Für alle $v,w \in V$ und alle $\lambda, \mu \in K$ gilt:
\begin{enumerate}
 \item $(\lambda + \mu) \cdot v  =(\lambda \cdot v) + ( \mu \cdot v)$.
\item $\lambda \cdot (v + w )  = ( \lambda \cdot v) + ( \lambda \cdot w)$.
\item $(\lambda \mu) \cdot v = \lambda \cdot (\mu \cdot v)$.
\item $1 \cdot v = v$.
\end{enumerate}
\end{enumerate}
\end{frame}

\begin{frame}{Begriffe}
\begin{itemize}
\item Die Elemente eines Vektorraums nennt man {\color{red} Vektoren}.
\item Die Abbildung $\cdot : K\times V \ \rightarrow \ V$ heißt
  {\color{red} Skalarmultiplikation}. Die Elemente des Körpers $K$ nennt man
  {\color{red} Skalare}.
\item  Ist $U \subset V$ eine Teilmenge des Vektorraums $V$ und gelten
  alle Vektorraumaxiome, so heißt $U$ ein {\color{red} Untervektorraum} oder
  {\color{red} Unterraum} von $V$. 
\item \alert{Vorsicht!} $0$ ist nicht gleich $0$, d.h. man muß zwischen der $0$ des Körpers und der $0$ des Vektorraums (Nullvektor) unterscheiden. Es gilt $0 \cdot v
  = 0$ für alle $v \in V$. 
\end{itemize}
\end{frame}

\begin{frame}{Beispiele für Vektorräume}
\begin{itemize}
\item $K^n := \{(x_1,\ldots,x_n) \;|\; x_1, \ldots, x_n \in K\}$, $n \in \mathbb{N}$
\item Sei $M$ eine beliebige Menge. Die Menge der Abbildungen von $M$
  in $K$, $\text{Abb}(M,K)$, mit den punktweise definiertenVerknüpfungen
\begin{eqnarray*}
(f+g)(x) & :=& f(x)+g(x), \forall\; x \in M\\
(\alpha \cdot f)(x) & :=& \alpha \cdot f(x), \forall\; x \in M  
\end{eqnarray*}
für $\alpha \in K$, $f,g:M \mapsto K$.
\item Die Menge der Polynome bis zum Grad $n$.
\item Die Menge aller Polynome.
\item $\mathbb{R}$ als $\mathbb{Q}$-Vektorraum.
\item $\mathbb{C}$ als $\mathbb{R}$-Vektorraum.
\end{itemize}
\end{frame} 


%\subsection{Vektoren und Basen}
\begin{frame}[fragile]{Vektoren in Sage}
\begin{itemize}
\item Konstruktion von Vektoren
\begin{sagein}
a = vector([1,2,3,4]); b = vector([5,6,7]); a,b
\end{sagein}
\begin{small}
\begin{sage}
((1, 2, 3, 4), (5, 6, 7))
\end{sage}
\end{small}
\item Datentyp: \isage{vector_integer_dense} (für dichte Vektoren)
\begin{sagein}
type(a)
\end{sagein}
\scriptsize{
\begin{sage}
<type 'sage.modules.vector_integer_dense.Vector_integer_dense'>
\end{sage}}
\end{itemize}
\end{frame}

\begin{frame}{Lineare Abhängigkeit}
Sei $V$ ein $K$-Vektorraum und $(v_1,\dots ,v_r)$ eine Familie von
Elementen aus $V$.
\begin{itemize}
\item $v \in V$ heißt {\color{red} Linearkombination} von $(v_1,\dots ,v_r)$,
  falls $\exists \lambda_1, \dots, \lambda_r \in K$  mit
  $ v= \lambda_1 v_1 + \dots + \lambda_r v_r$. 
\item Die Menge aller Linearkombinationen wird {\color{red} Lineare Hülle}
  genannt und durch $\mathop{span}\{v_1, \dots, v_n\}$ bezeichnet. Die Lineare
  Hülle ist ein Unterraum von $V$.
\item  $(v_1,\dots ,v_r)$ heißen {\color{red} linear unabhängig}, falls gilt:
  Sind $\lambda_1, \dots , \lambda_r \in K$ und ist $\lambda_1 v_1 +
  \dots + \lambda_r v_r=0$ so folgt $\lambda_1= \dots =
  \lambda_r=0$. Andernfalls sind sie {\color{red} linear abhängig}. 
\item Ist $M \subseteq V$ eine unendliche Menge, dann ist $M$ linear unabhängig falls \alert{alle endlichen} Teilmengen von $M$ lineare unabhängig sind.
\end{itemize}
\end{frame}

\begin{frame}{Weitere Notationen und Bemerkungen}
Sei $V$ ein $K$-Vektorraum und $(v_1,\dots ,v_r)$ eine Familie von
Elementen aus $V$
\begin{itemize}
\item $(v_1,\dots ,v_r)$ sind genau dann linear unabhängig, wenn sich
jeder Vektor $v \in span\{v_1, \dots ,v_r\}$ eindeutig linear kombinieren
läßt. 
\item Gilt $V=span\{v_1,\dots ,v_r \}$, so ist $(v_1, \dots ,v_r)$ ein
{\color{red} Erzeugendensystem}. Sind $(v_1, \dots ,v_r)$ zusätzlich linear
unabhängig, so ist $(v_1, \dots ,v_r)$ eine {\color{red} Basis}.
\item Aus jedem Erzeugendensystem kann man eine Basis auswählen. 
\end{itemize}
\end{frame}


\begin{frame}{Beispiele für Basen}
\begin{itemize}
\item Seien $(e_i)_{i=1,\ldots,n} \in \mathbb{R}^n$ die Einheitsvektoren. $(e_1, \dots
,e_n)$ ist eine Basis des $\mathbb{R}^n$.
\item Die Monombasis $(1,x,x^2,\dots, x^n)$ ist eine Basis des
Vektorraums der Polynome $n$-ten Grades.
\item $(1,i)$ ist eine Basis von $\mathbb{C}$ als
$\mathbb{R}$-Vektorraum. 
\item $\mathbb{R}$ als $\mathbb{Q}$-Vektorraum hat keine endliche
Basis. 
\end{itemize}
\end{frame}

\begin{frame}{Basis und Dimension}
\begin{itemize}
\item Sei $(v_1,\dots, v_n)$ eine Basis eines Vektorraums $V$. Dann
ist die {\color{red} Dimension} des Vektorraums $V$ definiert durch die Anzahl der
Basiselemente, also $n$.
\item Jeder Vektorraum besitzt eine Basis.
\item Seien $W,Z$ Unterräume von $V$. Dann ist {\color{red} $W+Z:=span(W \cup Z)$}
die {\color{red} Summe} von $W$ und $Z$. Es gilt:
\[ \dim(W+Z)=\dim(W) + \dim (Z) - \dim( W \cap Z) \]
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Bestimmen einer Basis von $span(s1,s2,s3)$
\begin{sagein}
s1 = vector([1,0,0])
s2 = vector([0,1,1])
s3 = vector([1,1,1])
span([s1,s2,s3],QQ)
\end{sagein}
\begin{sage}
Vector space of degree 3 and dimension 2 over Rational Field
Basis matrix:
[1 0 0]
[0 1 1]
\end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Bestimmen des Schnitts von $span(s1)$ und $span(s2,s3)$
\begin{sagein}
span([s1],QQ).intersection(span([s2,s3],QQ))
\end{sagein}
\begin{sage}
Vector space of degree 3 and dimension 1 over Rational Field
Basis matrix:
[1 0 0]
\end{sage}

\item Testen der linearen Unabhängigkeit
\begin{sagein}
m = matrix([s1,s2,s3]); m.rank() >= min(m.ncols, m.nrows)
\end{sagein}
\begin{sage}
  False
\end{sage}
\end{itemize}
\end{frame}



% \begin{frame}[fragile]{Exkurs: Bibliotheken in MuPAD}
% \begin{itemize}
% \item Eine Bibliothek besteht aus einer Sammlung von Funktionen zur
% Lösung von Problemen eines speziellen Gebietes (z.B. Lineare Algebra,
% Zahlentheorie, Numerik).
% \item Eine Übersicht aller Bibliotheken findet man in der 
% Kurzreferenz (über die  Hilfe erreichbar).
% \item Durch {\color{blue} \isage{?bib}} enthält man eine Auflistung der Funktionen
% in der Bibliothek {\color{blue}\isage{bib}}.
% \item Die Standardbibliothek {\color{blue}\isage{stdlib}} enthält die wichtigsten
% Basisfunktionen, die nicht im Kern implementiert sind. Diese
% Funktionen können direkt benutzt werden.
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Übersicht: Einige Bibliotheken}
% \begin{center}
% \begin{tabular}{|l|l|}
% \hline
% \isage{stdlib} & Standardbibliothek \\
% \isage{linalg} &  Lineare Algebra \\
% \isage{plot}   & Erzeugen von Grafiken\\
% \isage{numeric} & Numerische Berechnungen\\
% \isage{stats} & Statistische Berechnungen\\
% \isage{numlib} & Zahlentheorie\\
% \isage{student} & elementare Algorithmen\\ 
% \isage{fp} & Umgang mit Funktionen\\  
% \hline
% \end{tabular}
% \end{center}
% \end{frame}
% 
% \begin{frame}[fragile]{Benutzen der Bibliotheken}
% \begin{itemize}
% \item Eine Bibliotheksfunktion wird in der Form
% \isage{Bibliothek::Funktion} aufgerufen, z.B. {\color{blue}
% \isage{linalg::basis([s1,s2,s3])}}.
% \item Durch den Befehl {\color{blue} \isage{export(Bibliothek,Funktion)}} 
% 
% können Funktionen einer
% Bibliothek global bekannt gemacht werden. Dies bedeutet, dass die
% Funktion ohne Voranstellen des Bibliotheksnamen aufgerufen werden kann, z.B.
% \begin{sagein}
% export(student,isFree): 
% isFree([s1,s2,s3])
% \end{sagein}
% \begin{sage}
%   FALSE
% \end{sage}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[fragile]{Benutzen der Bibliotheken}
% \begin{itemize}
% \item Wird {\color{blue} \isage{export(Bibliothek)}} aufgerufen, so werden
% alle Funktionen der Bibliothek exportiert.
% \item Die Bibliotheken werden ständig aktualisiert und erweitert. In
% ihnen steckt das eigentliche mathematische Wissen. 
% \end{itemize}
% \end{frame}


% \begin{frame}[fragile]{Systemfunktionen}
% Viele Systemfunktionen lassen sich auf Matrizen anwenden. Beispiele:
% \begin{itemize}
% \item \isage{conjugate(A)} ersetzt die Komponenten durch ihre komplex
% konjugierten Einträge.
% \item \isage{expand(A)} wendet \isage{expand} auf alle Komponenten an.
% \item \isage{float(A)} wendet \isage{float} auf alle Komponenten  an.
% \item \isage{has(A,Ausdruck)} prüft, ob ein Ausdruck \isage{Ausdruck} in
% mind. einer Komponente von $A$ enthalten ist.
% \end{itemize} 
% \end{frame}


\begin{frame}{Normen auf Vektorräumen}
Sei $V$ ein Vektorraum über $K=\mathbb{R}$ oder $K=\mathbb{C}$.\\
Eine {\color{red} Norm} auf $V$ ist eine Abbildung
\[ \| \cdot \|: V \ \rightarrow \mathbb{R}, v \mapsto \| v \|, \]
so dass für  alle $\alpha \in K$, $u,v \in V$ gilt 
\[ \begin{array} {rcl}
\| v \| & \geq & 0 \\
\| v \| & = & 0 \mbox{ impliziert } v=0\\
\| \alpha v \| & = & | \alpha | \| v \|\\
\| u + v \| & \leq & \| u \| + \| v \| \mbox{ (Dreiecksungleichung)}.\\
\end{array} \]
$(V,\| \cdot \|)$
heißt {\color{red} normierter Raum}.
\end{frame}

\begin{frame}[fragile]{Skalarprodukt}
Eine skalarwertige binäre Abbildung
\[ ( \cdot, \cdot ): V \times V: \ \rightarrow \ K\]
auf einem Vektorraum $V$ über $K=\mathbb{R}$ oder $K=\mathbb{C}$ heißt
{\color{red} Skalarprodukt}, wenn für alle $x,y,z \in V$, $\alpha, \beta \in
K$ gilt 
\begin{eqnarray*}
(x,x) & \geq & 0\\
(x,x) & = & 0 \mbox{ impliziert } x=0.\\
(x,y) & = & \overline{(y,x)}\\
(\alpha x+\beta y,z) & = & \alpha (x,z)+ \beta (y,z)
\end{eqnarray*}
\end{frame}

\begin{frame}{Bemerkungen}
\begin{itemize}
\item Ein VR $V$ mit Skalarprodukt heißt {\color{red} Prä-Hilbert-Raum}. Ist
$K=\mathbb{R}$ so heißt der Raum auch {\color{red} euklidisch}.
\item Durch $\|v\|:=\sqrt{(v,v)}$, $v \in V$ läßt sich eine Norm
definieren. Es gilt die {\color{red} Cauchy-Schwarzsche Ungleichung}
\[ |(u,v)| \leq \| u \| \|v\|. \]
\item Im euklidischen Raum ist der Winkel $\alpha$ zwischen zwei Vektoren
$u,v \in V\smallsetminus \{ 0 \}$ definiert durch
\[ \cos(\alpha) = \frac{(u,v)}{\|u\| \|v \|}. \]
   \end{itemize}
\end{frame}


\begin{frame}{Bemerkungen}
\begin{itemize}
\item Zwei Vektoren $u,v \in V$ heißen {\color{red} orthogonal}, wenn
$(u,v)=0$ gilt. 
\item Eine Basis aus paarweise orthogonalen Vektoren heißt {\color{red}
Orthogonalbasis}. 
\item Eine Orthogonalbasis, bei der alle Vektoren die Norm $1$
haben, nennt man {\color{red} Orthonormalbasis}.
\item Jeder endlichdimensionale Prä-Hilbert-Raum hat eine
Orthonormalbasis. 
\item Ist $U$ ein Unterraum von $V$, so ist
\[
{U}^\perp := \{ v \in V \ | \ (v,u)=0 \mbox{ für alle } u \in U \}
\]
der {\color{red} Orthogonalraum} zu $U$. Er ist ein Untervektorraum.
\item Es gilt: $\dim U + \dim U^\perp = \dim V$, insb. $U \cap U^\perp = 0$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Die $p$-Norm $\|v\|:=(\sum_{i=1}^n |v_i|^p)^{1/p}$, $p\in [1,\infty)$ auf dem
$K^n$ mit $K=\mathbb{R},\mathbb{C}$ wird berechnet durch:
\begin{sagein}
x = vector([1,2,3,4,5]); p=2
x.norm(p)
\end{sagein}
\item sind Vektoren orthogonal zueinander ?
\begin{sagein}
a1 = vector([1,2,3])
a2 = vector([0,4,1])
a3 = vector([1,1,1])
X = matrix([a1,a2,a3])
X * X.transpose() 
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Berechnen des Skalarprodukts
\begin{sagein}
a2.dot_product(a3), a2*a3
\end{sagein}
\begin{sage}
  (5, 5)
\end{sage}
\item Berechnen des Winkels zwischen zwei Vektoren
\begin{sagein}
float(acos(a2*a3/(abs(a2)*abs(a3))))
\end{sagein}
\begin{sage}
  0.79520271328967818
\end{sage}
\item Berechnen der Determinante
\begin{sagein}
A = matrix([[1,2,3],[4,5,6],[7,8,0]])
A.det()
\end{sagein}
\begin{sage}
  27
\end{sage}
\end{itemize}
\end{frame}

%===============================
\section{Programmieren I}
%===============================

\begin{frame}[fragile]{Ein erstes Programm}
\begin{sagein}
def MyMax(a,b):
    """Maximum von a und b"""
    if a<b:
        return (b)
    else: 
        return (a)
\end{sagein}
\begin{itemize}
\item Das erste Beispiel berechnet das Maximum zweier Zahlen $a$ und
$b$. 
\item Aufruf in Sage ist {\color{blue} \isage{MyMax(a,b)}}. 
\item Die Funktion gibt dann entweder den Wert $a$ oder den Wert $b$
  zurück.
\item in \isage{\"\"\" comment \"\"\"} eingeschlossene Zeilen werden als Hilfetext abgespeichert und können durch \isage{MyMax?} abgefragt werden.
 \end{itemize} 
\end{frame}

\begin{frame}[fragile]{Aufbau von Funktionen}
\begin{itemize}
\item Eine Funktion beginnt mit \isage{def} und dem Namen der Prozedur (hier:
  \isage{MyMax}) gefolgt von den möglichen Übergabeparameter \isage{(a,b,c..)}
\item Jede Zeile, die einen folgenden Block einleitet, muss mit einem Doppelpunkt \isage{:} abgeschlossen werden.
\item Jede Zeile in diesem Block muss eine grössere Einrückung besitzen (typischerweise ein \emph{Tab})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Return}
\begin{itemize}
\item Mittels \isage{return(a)} wird die Funktion abgebrochen und der
Wert \isage{a} zurückgegeben.
\item Wird innerhalb der Prozedur kein Befehl ausgeführt, so wird eine leere Variable des Typs
\isage{NoneType} zurückgegeben.  
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Erkärungen}
\begin{itemize}
\item Kommentarzeilen: Diese beginnen mit \isage{#}. Sie werden vom System ignoriert.
\item Die durch \isage{if <bedingung>:} eingeleitete Zeile ist eine
  sogenannte Verzweigung. Ist die  Bedingung \isage{<bedingung>} wahr, so wird der
  Block hinter \isage{:} ausgeführt. Ist \isage{<bedingung>} falsch, so
  wird die Alternative \isage{else:} ausgeführt.
\item \emph{Achtung:} in Sage (und Python) wird der Block durch die Einrückung definiert. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Erstellen von Funktionen}
Bei umfangreicheren Funktionen oder richtigen Programmen ist es evtl. sinnvoller dies mit
einem Editor zu erstellen. 

\begin{itemize}
 \item Erstellen einer \verb+<name>.sage+-Datei in \verb+~/.sage+. Diese mit Sage-Code füllen
\item In sage diese mit \isage{attach <name>.sage} an das Notebook anhängen $\Rightarrow$ wird automatisch geladen und aktuell gehalten.
\item als Editor empfehle ich zum Einstieg \verb+geany+. Prinzipiell sind alle Editoren geeignet die Python unterstützen.
\end{itemize}

\end{frame}
\end{document}
