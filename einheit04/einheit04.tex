\documentclass[notes=hide,hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Sage - Einheit 4}
\subtitle{Matrizen, Vektorräume, Funktionen}
\input{../slide_header}
\maketitle

\begin{frame}{Aufbau}
\tableofcontents
\end{frame}

% \begin{frame}{Übersicht}
% \begin{itemize}
% \item Vektoren
% \item Vektorräume
% \item Lineare Unabhängigkeit, Basis
% \item Matrizen
% \item MuPAD-Bibliotheken
% \item Ein erstes Programm
% \end{itemize}
% \end{frame}

%===================================================
\section{Vektoren}
%==================================================
\subsection{Matrizen}

\begin{frame}{Matrizen}

{\color{red} $m \times n$ Matrix} $A=(a_{ij}) \in K^{m\times n}$ über einen Körper $K$ 

\[ A = \left( \begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn} 
\end{array} \right) \] 
$a_{ij} \in K$, Zeilenindex $i \in [1,m]$, Spaltenindex $j \in [1,n]$

\end{frame}

\begin{frame}{Definitionen}
\begin{itemize}
\item {\color{red} Transponiert} von $A=(a_{ij})$: $A^T:=(a_{ji})$ .
\item {\color{red} Symmetrisch}: wenn $A=A^T$ gilt.
\item \alert{Adjungiert} von $A=(a_{ij})\in \mathbb{C}^{m\times n}$: $A^* :=
(\overline{a_{ji}}) \in \mathbb{C}^{n \times m}$.
\item \alert{Einheitsmatrix}: $I:=I_n:=(\delta_{ij}) \in K^{n \times
n}$
\item {\color{red} Addition}: Seien $A=(a_{ij}),B=(b_{ij}) \in {K}^{n \times m}$, dann
\[ C=(c_{ij}):=A+B \in {K}^{n \times m} \]
mit $c_{ij}=a_{ij}+b_{ij}$.  
\end{itemize}
\end{frame} 

\begin{frame}{Definitionen}
\begin{itemize}
\item {\color{red} Multiplikation}: Seien $A=(a_{ij}) \in {K}^{m \times n}$ und $B=(b_{ij})
\in {K}^{n \times p}$, dann 
\[ C=(c_{ij}):=A \cdot B \in{K}^{m \times p} \]
mit $c_{ij}=\sum_{k=1}^n a_{ik} b_{kj}$. 
\item {\color{red} orthogonal}: $A \cdot A^T=A^T \cdot A=I_n$ für $A\in K^{n \times n}$ 
\item {\color{red} unitär}: $A \cdot A^*=A^* \cdot A=I_n$ für $A\in \mathbb{C}^{n \times n}$.
\item {\color{red} invertierbar}: $A\in K^{n \times n}$ heißt , wenn eine
Matrix $A^{-1}\in K^{n \times n}$ existiert mit  $A \cdot
A^{-1}=A^{-1} \cdot A=I_n$.
\end{itemize}
\end{frame} 

\begin{frame}{Definitionen und Bemerkungen}
\begin{itemize}
\item Die Multiplikation ist assoziativ aber in der Regel \alert{nicht kommutativ}. 
\item Die Matrizen aus $K^{m \times n}$ bilden einen Vektorraum über
$K$ (mit komponentenweiser Skalarmultiplikation).
\item {\color{red} allgemeine
lineare Gruppe} $\operatorname{GL}(K,n) = \operatorname{GL}_n(K) = \operatorname{GL}(n,K)$: 
Die Menge der invertierbaren Matrizen aus $K^{n \times n}$ bilden bezüglich der Multiplikation eine Gruppe.
\item {\color{red} orthogonale Gruppe}: $O(n)$: Die Menge der orthogonalen Matrizen in $GL(\mathbb{R},n)$ bilden
 eine Untergruppe von  $GL(\mathbb{R},n)$. 
\item  {\color{red} unitäre Gruppe} $U(n)$: Die entsprechende Untergruppe der unitären Matrizen in $GL(\mathbb{C},n)$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Matrizen in Sage}

\begin{sagein}
matrix([[a11,a12,...],[a21,a22,..],..])
\end{sagein}

\begin{itemize}
\item Der Rückgabewert ist vom Typ \isage{matrix}.
\item Die Einträge der Matrix können beliebige Ausdrücke sein.
\item Es ist möglich Matrizen über bestimmten Bereichen
(z.B. $\mathbb{R}$, $\mathbb{C}$, $\mathbb{Z}$) zu
konstruieren.                                                     
\item Es gibt spezielle Datenstrukturen für quadratische Matrizen und für dünnbesetzte Matrizen. 
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Konstruktion von Matrizen I}
Es gibt in Sage verschiedene Möglichkeiten eine Matrix zu
konstruieren. Beispiel:
\[ A:= \left( \begin{array}{cccc}
1 & 2 & 3 & 4\\
a & 0 & 1 & b\\ 
\end{array} \right), \quad a,b\in \mathbb{R} \]
\begin{itemize}
\item Einträge pro Zeile in eckigen Klammern $[ ..]$. Alle
Spalten dann wieder in eckigen Klammern $[ ..]$ (Standard)
\begin{sagein}
A = matrix([[1, 2, 3, 4],[a, 0, 1, b]]) 
\end{sagein}
\item Explizite Größenangabe
\begin{sagein}
A = matrix(2,4,[[1,2,3,4],[a,0,1,b]]) 
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Konstruktion von Matrizen II}
\begin{itemize}
\item Nullmatrix der Größe $n \times m$:
\begin{sagein}
n = 3; m = 4; B = matrix(n,m)
\end{sagein}
\item Erzeugung mit Hilfe einer Funktion $f(i,j)$ mit Einträgen $a_{ij}=f(i,j)$
\begin{sagein}
f(i,j) = i*j
C = matrix([[f(i,j) for i in range(1,6)] for j in range(1,4)]); C
\end{sagein}
\item Eingabe von Zeilen- und Spaltenvektoren (falls explizit nötig)
\begin{sagein}
matrix(3,1,[1,2,3])
matrix(1,3,[4,5,6])
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zeilen- und Spaltenzahl}
\begin{itemize}
\item Spaltenanzahl: \isage{<matrix>.ncols()}
\begin{sagein}
C.ncols()
\end{sagein}
\begin{sage}
  5
\end{sage}
\item Zeilenanzahl: \isage{<matrix>.nrows()}
\begin{sagein}
C.nrows()
\end{sagein}
\begin{sage}
  3
\end{sage}
\item Informationen über die Matrix: \isage{<matrix>.parent()}
\begin{sagein}
C.parent()
\end{sagein}
\begin{sage}
Full MatrixSpace of 3 by 5 dense matrices over Symbolic Ring
\end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zugriff auf die Einträge I}
\begin{itemize}
\item Zugriff auf Einträge in Zeile $i$ und Spalte $j$:
\begin{sagein}
i=1; j=2; C[i,j]
\end{sagein}
\begin{sage}
  6
\end{sage}
\item Ändern eines Eintrags in Zeile $i$ und Spalte $j$:
\begin{sagein}
i=1; j=2; C[i,j]=22
\end{sagein}
\item Extrahieren von Zeilen/Spalten
\begin{sagein}
zeile = C.row(0)
spalte = C.column(4)
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zugriff auf die Einträge II}
\begin{itemize}
\item Teilmatrizen
\begin{sagein}
C[1:3,1:3]
\end{sagein}
\item Diagonalmatrizen
\begin{sagein}
x = [1,2,3,4,5]
Diag = diagonal_matrix(x); Diag
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Rechnen mit Matrizen}
\begin{itemize} 
\item Addieren, Multiplizieren
\begin{sagein}
var('a,b,c,d,g,h,f')
A = matrix([[a, b], [c,d]])
B = matrix([[e, f], [g,h]])
A+B; A*B
\end{sagein}
\item Inverse und der Transponierte
\begin{sagein}
A^(-1); A.transpose()
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}{Rang von Matrizen}
Sei $A \in K^{m \times n}$. 
\begin{itemize}
\item {\color{red} Spaltenrang}: Die Dimension der linearen Hülle der Spaltenvektoren. Er ist höchstens gleich $n$.
\item {\color{red} Zeilenrang}: Die Dimension der linearen Hülle der Zeilenvektoren. Er ist höchstens gleich $m$.
\item {\color{red} Rang}: Abkürzung, da Zeilenrang und Spaltenrang von Matrizen gleich sind. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Matrizen}
\begin{itemize}
\item Bestimmen des Ranges einer Matrix
\begin{sagein}
S = matrix([[1,0,0],[0,1,1],[1,1,1]])
S.rank()
\end{sagein}
\begin{sage}
  2
\end{sage}
\item ist S symmetrisch ? ist S invertierbar ?
\begin{sagein}
S.is_symmetric() 
S.is_invertible()
\end{sagein}
\begin{sage}
False
False
\end{sage}
\item Determinante
\begin{sagein}
S.det()
\end{sagein}
\begin{sage}
  27
\end{sage}

% \item Ist eine Matrix unitär ?
% \begin{sagein}
% linalg::isUnitary(S)
% \end{sagein}
% \begin{sage}
%   FALSE
% \end{sage}
% \begin{sagein}
% F:=matrix([[I,0],[0,-I]])
% linalg::isUnitary(F)
% \end{sagein}
% \begin{sage}
%   TRUE
% \end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Maps auf Matrizen}
Anwendung der Funktion \isage{<function>} auf \isage{<matrix>} (siehe auch \isage{map()})\\
\begin{sagein}
map_threaded(<function>,<matrix>)
\end{sagein}
\textbf{Beispiel}:
\begin{sagein}
map_threaded(sqrt,matrix(RR,[[1,2],[3,4]]))
\end{sagein}
  	
\begin{sage}
[1.00000000000000 1.41421356237310]
[1.73205080756888 2.00000000000000] 
\end{sage}

\end{frame}





\subsection{Vektorräume}
\begin{frame}{Vektorraum}
Ein Tripel $(V,+,\cdot)$, bestehend aus einer nichtleeren Menge $V$
und Verknüpfungen
\[ +:V \times V \ \rightarrow \ V, \qquad \cdot:K\times V \ \rightarrow \ V\]
heißt {\color{red} Vektorraum} über einem Körper
$K$, wenn gilt:
\begin{enumerate}
\item $(V,+)$ ist eine abelsche Gruppe.
\item Für alle $v,w \in V$ und alle $\lambda, \mu \in K$ gilt:
\begin{enumerate}
 \item $(\lambda + \mu) \cdot v  =(\lambda \cdot v) + ( \mu \cdot v)$.
\item $\lambda \cdot (v + w )  = ( \lambda \cdot v) + ( \lambda \cdot w)$.
\item $(\lambda \mu) \cdot v = \lambda \cdot (\mu \cdot v)$.
\item $1 \cdot v = v$.
\end{enumerate}
\end{enumerate}
\end{frame}

\begin{frame}{Begriffe}
\begin{itemize}
\item {\color{red} Vektoren}: Die Elemente eines Vektorraums.
\item {\color{red} Skalarmultiplikation}: Die Abbildung $\cdot : K\times V \ \rightarrow \ V$. Die Elemente des Körpers $K$ nennt man
  {\color{red} Skalare}.
\item {\color{red} Untervektorraum} oder {\color{red} Unterraum} von $V$: Ist $U \subset V$ eine Teilmenge des Vektorraums $V$ und es gelten
  alle Vektorraumaxiome.
\item \alert{Vorsicht!} man muß zwischen der $0$ des Körpers und der $0$ des Vektorraums (Nullvektor) unterscheiden. \\
Es gilt $0 \cdot v  = 0$ für alle $v \in V$. 
\end{itemize}
\end{frame}

\begin{frame}{Beispiele für Vektorräume}
\begin{itemize}
\item $K^n := \{(x_1,\ldots,x_n) \;|\; x_1, \ldots, x_n \in K\}$, $n \in \mathbb{N}$
\item Sei $M$ eine beliebige Menge. Die Menge der Abbildungen von $M$
  in $K$, $\text{Abb}(M,K)$, mit den punktweise definiertenVerknüpfungen
\begin{eqnarray*}
(f+g)(x) & :=& f(x)+g(x), \forall\; x \in M\\
(\alpha \cdot f)(x) & :=& \alpha \cdot f(x), \forall\; x \in M  
\end{eqnarray*}
für $\alpha \in K$, $f,g:M \mapsto K$.
\item Die Menge der Polynome bis zum Grad $n$.
\item Die Menge aller Polynome.
\item $\mathbb{R}$ als $\mathbb{Q}$-Vektorraum.
\item $\mathbb{C}$ als $\mathbb{R}$-Vektorraum.
\end{itemize}
\end{frame} 


%\subsection{Vektoren und Basen}
\begin{frame}[fragile]{Vektoren in Sage}
Konstruktion von Vektoren
\begin{sagein}
vector([v1,v2,..]) 
\end{sagein}
\textbf{Beispiele}:
\begin{itemize}
\item Konstruktion
\begin{sagein}
a = vector([1,2,3,4]); b = vector([5,6,7]); a,b
\end{sagein}
\begin{small}
\begin{sage}
((1, 2, 3, 4), (5, 6, 7))
\end{sage}
\end{small}
\item Datentyp: \isage{vector_integer_dense} (für dichte Vektoren)
\begin{sagein}
type(a)
\end{sagein}
\scriptsize{
\begin{sage}
<type 'sage.modules.vector_integer_dense.Vector_integer_dense'>
\end{sage}}
\end{itemize}
\end{frame}

\begin{frame}{Lineare Abhängigkeit}
Sei $V$ ein $K$-Vektorraum und $(v_1,\dots ,v_r)$ eine Familie von
Elementen aus $V$.
\begin{itemize}
\item {\color{red} Linearkombination} $v \in V$ von $(v_1,\dots ,v_r)$: 
  falls $\exists \lambda_1, \dots, \lambda_r \in K$  mit
  $ v= \lambda_1 v_1 + \dots + \lambda_r v_r$. 
\item {\color{red} Lineare Hülle} $\mathop{span}\{v_1, \dots, v_n\}$: Die Menge aller Linearkombinationen. Die Lineare
  Hülle ist ein Unterraum von $V$.
\item {\color{red} linear unabhängig}: 
  Sind $\lambda_1, \dots , \lambda_r \in K$ und ist $\lambda_1 v_1 +
  \dots + \lambda_r v_r=0$ so folgt $\lambda_1= \dots =
  \lambda_r=0$. Andernfalls {\color{red} linear abhängig}. 
\begin{itemize}
\item Ist $M \subseteq V$ eine unendliche Menge, dann ist $M$ linear unabhängig falls alle endlichen Teilmengen von $M$ linear unabhängig sind.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Weitere Notationen und Bemerkungen}
Sei $V$ ein $K$-Vektorraum und $(v_1,\dots ,v_r)$ eine Familie von
Elementen aus $V$
\begin{itemize}
\item $(v_1,\dots ,v_r)$ sind genau dann linear unabhängig, wenn sich
jeder Vektor $v \in span\{v_1, \dots ,v_r\}$ eindeutig linear kombinieren
läßt. 
\item Vektoren sind linear unabhängig wenn die Determinante der korrelierenden Matrix ungleich 0 ist.
\item Gilt $V=span\{v_1,\dots ,v_r \}$, so ist $(v_1, \dots ,v_r)$ ein
{\color{red} Erzeugendensystem}. Sind $(v_1, \dots ,v_r)$ zusätzlich linear
unabhängig, so ist $(v_1, \dots ,v_r)$ eine {\color{red} Basis}.
\item Aus jedem Erzeugendensystem kann man eine Basis auswählen. 
\end{itemize}
\end{frame}


\begin{frame}{Beispiele für Basen}
\begin{itemize}
\item Seien $(e_i)_{i=1,\ldots,n} \in \mathbb{R}^n$ die Einheitsvektoren. $(e_1, \dots
,e_n)$ ist eine Basis des $\mathbb{R}^n$.
\item Die Monombasis $(1,x,x^2,\dots, x^n)$ ist eine Basis des
Vektorraums der Polynome $n$-ten Grades.
\item $(1,i)$ ist eine Basis von $\mathbb{C}$ als
$\mathbb{R}$-Vektorraum. 
\item $\mathbb{R}$ als $\mathbb{Q}$-Vektorraum hat keine endliche
Basis. 
\end{itemize}
\end{frame}

\begin{frame}{Basis und Dimension}
\begin{itemize}
\item {\color{red} Dimension} des Vektorraums $V$: die  Anzahl der Basiselemente einer Basis $(v_1,\dots, v_n)$.
\item Jeder Vektorraum besitzt eine Basis.
\item Seien $W,Z$ Unterräume von $V$. Dann ist {\color{red} $W+Z:=span(W \cup Z)$}
die {\color{red} Summe} von $W$ und $Z$. Es gilt:
\[ \dim(W+Z)=\dim(W) + \dim (Z) - \dim( W \cap Z) \]
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Bestimmen einer Basis von $span(s1,s2,s3)$
\begin{sagein}
s1 = vector([1,0,0])
s2 = vector([0,1,1])
s3 = vector([1,1,1])
span([s1,s2,s3],QQ)
\end{sagein}
\begin{sage}
Vector space of degree 3 and dimension 2 over Rational Field
Basis matrix:
[1 0 0]
[0 1 1]
\end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Bestimmen des Schnitts von $span(s1)$ und $span(s2,s3)$
\begin{sagein}
span([s1],QQ).intersection(span([s2,s3],QQ))
\end{sagein}
\begin{sage}
Vector space of degree 3 and dimension 1 over Rational Field
Basis matrix:
[1 0 0]
\end{sage}

\item Testen der linearen Unabhängigkeit
\begin{sagein}
m = matrix([s1,s2,s3])
m.rank() >= min(m.ncols(), m.nrows())
m.determinant() <> 0 
\end{sagein}

\begin{sage}
  False
\end{sage}
\end{itemize}
\end{frame}



% \begin{frame}[fragile]{Exkurs: Bibliotheken in MuPAD}
% \begin{itemize}
% \item Eine Bibliothek besteht aus einer Sammlung von Funktionen zur
% Lösung von Problemen eines speziellen Gebietes (z.B. Lineare Algebra,
% Zahlentheorie, Numerik).
% \item Eine Übersicht aller Bibliotheken findet man in der 
% Kurzreferenz (über die  Hilfe erreichbar).
% \item Durch {\color{blue} \isage{?bib}} enthält man eine Auflistung der Funktionen
% in der Bibliothek {\color{blue}\isage{bib}}.
% \item Die Standardbibliothek {\color{blue}\isage{stdlib}} enthält die wichtigsten
% Basisfunktionen, die nicht im Kern implementiert sind. Diese
% Funktionen können direkt benutzt werden.
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Übersicht: Einige Bibliotheken}
% \begin{center}
% \begin{tabular}{|l|l|}
% \hline
% \isage{stdlib} & Standardbibliothek \\
% \isage{linalg} &  Lineare Algebra \\
% \isage{plot}   & Erzeugen von Grafiken\\
% \isage{numeric} & Numerische Berechnungen\\
% \isage{stats} & Statistische Berechnungen\\
% \isage{numlib} & Zahlentheorie\\
% \isage{student} & elementare Algorithmen\\ 
% \isage{fp} & Umgang mit Funktionen\\  
% \hline
% \end{tabular}
% \end{center}
% \end{frame}
% 
% \begin{frame}[fragile]{Benutzen der Bibliotheken}
% \begin{itemize}
% \item Eine Bibliotheksfunktion wird in der Form
% \isage{Bibliothek::Funktion} aufgerufen, z.B. {\color{blue}
% \isage{linalg::basis([s1,s2,s3])}}.
% \item Durch den Befehl {\color{blue} \isage{export(Bibliothek,Funktion)}} 
% 
% können Funktionen einer
% Bibliothek global bekannt gemacht werden. Dies bedeutet, dass die
% Funktion ohne Voranstellen des Bibliotheksnamen aufgerufen werden kann, z.B.
% \begin{sagein}
% export(student,isFree): 
% isFree([s1,s2,s3])
% \end{sagein}
% \begin{sage}
%   FALSE
% \end{sage}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[fragile]{Benutzen der Bibliotheken}
% \begin{itemize}
% \item Wird {\color{blue} \isage{export(Bibliothek)}} aufgerufen, so werden
% alle Funktionen der Bibliothek exportiert.
% \item Die Bibliotheken werden ständig aktualisiert und erweitert. In
% ihnen steckt das eigentliche mathematische Wissen. 
% \end{itemize}
% \end{frame}


% \begin{frame}[fragile]{Systemfunktionen}
% Viele Systemfunktionen lassen sich auf Matrizen anwenden. Beispiele:
% \begin{itemize}
% \item \isage{conjugate(A)} ersetzt die Komponenten durch ihre komplex
% konjugierten Einträge.
% \item \isage{expand(A)} wendet \isage{expand} auf alle Komponenten an.
% \item \isage{float(A)} wendet \isage{float} auf alle Komponenten  an.
% \item \isage{has(A,Ausdruck)} prüft, ob ein Ausdruck \isage{Ausdruck} in
% mind. einer Komponente von $A$ enthalten ist.
% \end{itemize} 
% \end{frame}


\begin{frame}{Normen auf Vektorräumen}
Sei $V$ ein Vektorraum über $K=\mathbb{R}$ oder $K=\mathbb{C}$.\\
Eine {\color{red} Norm} auf $V$ ist eine Abbildung
\[ \| \cdot \|: V \ \rightarrow \mathbb{R}, v \mapsto \| v \|, \]
so dass für  alle $\alpha \in K$, $u,v \in V$ gilt 
\[ \begin{array} {rcl}
\| v \| & \geq & 0 \\
\| v \| & = & 0 \mbox{ impliziert } v=0\\
\| \alpha v \| & = & | \alpha | \| v \|\\
\| u + v \| & \leq & \| u \| + \| v \| \mbox{ (Dreiecksungleichung)}.\\
\end{array} \]
$(V,\| \cdot \|)$
heißt {\color{red} normierter Raum}.
\end{frame}

\begin{frame}[fragile]{Skalarprodukt}
Eine skalarwertige binäre Abbildung
\[ ( \cdot, \cdot ): V \times V: \ \rightarrow \ K\]
auf einem Vektorraum $V$ über $K=\mathbb{R}$ oder $K=\mathbb{C}$ heißt
{\color{red} Skalarprodukt}, wenn für alle $x,y,z \in V$, $\alpha, \beta \in
K$ gilt 
\begin{eqnarray*}
(x,x) & \geq & 0\\
(x,x) & = & 0 \mbox{ impliziert } x=0.\\
(x,y) & = & \overline{(y,x)}\\
(\alpha x+\beta y,z) & = & \alpha (x,z)+ \beta (y,z)
\end{eqnarray*}
\end{frame}

\begin{frame}{Bemerkungen}
\begin{itemize}
\item Ein VR $V$ mit Skalarprodukt heißt {\color{red} Prä-Hilbert-Raum}. Ist
$K=\mathbb{R}$ so heißt der Raum auch {\color{red} euklidisch}.
\item Durch $\|v\|:=\sqrt{(v,v)}$, $v \in V$ läßt sich eine Norm
definieren. Es gilt die {\color{red} Cauchy-Schwarzsche Ungleichung}
\[ |(u,v)| \leq \| u \| \|v\|. \]
\item Im euklidischen Raum ist der Winkel $\alpha$ zwischen zwei Vektoren
$u,v \in V\smallsetminus \{ 0 \}$ definiert durch
\[ \cos(\alpha) = \frac{(u,v)}{\|u\| \|v \|}. \]
   \end{itemize}
\end{frame}


\begin{frame}{Bemerkungen}
\begin{itemize}
\item {\color{red} Orthogonal}: wenn $(u,v)=0$ gilt.
\item {\color{red} Orthogonalbasis}: Eine Basis aus paarweise orthogonalen Vektoren. 
\item {\color{red} Orthonormalbasis}: Eine Orthogonalbasis, bei der alle Vektoren die Norm $1$
haben.
\item Jeder endlichdimensionale Prä-Hilbert-Raum hat eine
Orthonormalbasis. 
\item {\color{red} Orthogonalraum}:
\[
{U}^\perp := \{ v \in V \ | \ (v,u)=0 \mbox{ für alle } u \in U \}
\]
wenn $U$ ein Unterraum von $V$ ist.
\item Es gilt: $\dim U + \dim U^\perp = \dim V$, insb. $U \cap U^\perp = 0$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item $p$-Norm:
\[
\|v\|:=(\sum_{i=1}^n |v_i|^p)^{1/p}, p\in [1,\infty)                   
\]
auf $K^n$ mit $K=\mathbb{R},\mathbb{C}$
\begin{sagein}
x = vector([1,2,3,4,5]); p=2
x.norm(p)
\end{sagein}
\item sind Vektoren orthogonal zueinander ?
\begin{sagein}
a1 = vector([1,2,3])
a2 = vector([0,4,1])
a3 = vector([1,1,1])
X = matrix([a1,a2,a3])
X * X.transpose() 
\end{sagein}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sage}
\begin{itemize}
\item Berechnen des Skalarprodukts
\begin{sagein}
a2.dot_product(a3), a2*a3
\end{sagein}
\begin{sage}
  (5, 5)
\end{sage}
\item Berechnen des Winkels zwischen zwei Vektoren
\begin{sagein}
float(acos(a2*a3/(abs(a2)*abs(a3))))
\end{sagein}
\begin{sage}
  0.79520271328967818
\end{sage}
\end{itemize}
\end{frame}

%===============================
\section{Funktionen}
%===============================

\begin{frame}[fragile]{Aufbau von Funktionen}
\begin{sagein}
def <Name><(a,b,..)>:
    <Code-Block>
    return <ret>
\end{sagein}
\begin{itemize}
\item Argumente/Übergabeparameter \isage{(a,b,..)} 
\item Jede Zeile, die einen folgenden Block einleitet, muss mit einem Doppelpunkt \isage{:} abgeschlossen werden.
\item Jede Zeile in diesem Block muss eine grössere Einrückung besitzen (typischerweise ein \emph{Tab})
\item Zeilen gleicher Einrückung gehören zum gleichen Block.
\item Rückgabewert \isage{ret} mittels \isage{return(ret)} zurückgegeben. Funktion ist dann beendet.
\item Ohne return wird eine leere Variable des Typs \isage{NoneType} zurückgegeben.  
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Erklärungen/Kommentare }
\begin{itemize}
\item In \isage{\"\"\" comment \"\"\"} eingeschlossene Zeilen werden als Hilfetext abgespeichert und können durch \isage{<funktionsname>?} abgefragt werden.
\item Kommentarzeilen: Diese beginnen mit \isage{#}. Sie werden vom System ignoriert.
%\item Die durch \isage{if <bedingung>:} eingeleitete Zeile ist eine
%  sogenannte Verzweigung. Ist die  Bedingung \isage{<bedingung>} wahr, so wird der
%  Block hinter \isage{:} ausgeführt. Ist \isage{<bedingung>} falsch, so
%  wird die Alternative \isage{else:} ausgeführt.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Eine Beispiel-Funktion}
\begin{sagein}
def MyMax(a,b):
    """Maximum von a und b"""
    if a<b:
        return (b)
    else: 
        return (a)
\end{sagein}
\begin{itemize}
\item Das Beispiel berechnet das Maximum zweier Zahlen $a$ und
$b$. 
\item Aufruf in Sage ist {\color{blue} \isage{MyMax(a,b)}}. 
\item Die Funktion gibt dann entweder den Wert $a$ oder den Wert $b$
  zurück.
 \end{itemize} 
\end{frame}



\begin{frame}[fragile]{Externes Editieren von Funktionen}
Bei umfangreicheren Funktionen oder richtigen Programmen ist es evtl. sinnvoller dies mit
einem Editor zu erstellen. 

\begin{itemize}
 \item Erstellen einer \verb+<name>.sage+-Datei (Editor: z.B. \verb+geany+)
\item \isage{attach <path>/<name>.sage}: hängt die Datei an das Notebook an und wird automatisch geladen und aktuell gehalten.
\item \isage{attached_files()}: listet alle angehängte Dateien.
\end{itemize}

\end{frame}
\end{document}
