\documentclass[notes=hide,hyperref={dvipdfmx,pdfpagelabels=false}]{beamer}
\title{Einführung in Sage - Einheit 9}
\subtitle{Strings, interaktive Grafiken, Wärmeleitungsgleichung, Sage-Code, geogebra ?, interface zu anderen}
\input{../slide_header}
\maketitle

\begin{frame}{Aufbau}
\tableofcontents
\end{frame}

\begin{frame}{Klausur}
 \begin{itemize}
\item Zeit: 01.03.2010 von 10:00 - 12:00
\item  Ort: HS1 (A bis J) und AudiMax (K bis Z)
\item  Hilfsmittlel: Papier, Schreibgerät(e) und Unterlagen in Papierform
\item  Studenten-Ausweis mitbringen
%\item  Ab 10:30 keine vorzeitige Abgabe möglich
\end{itemize}

\end{frame}

%===================================================
\section{Umgang mit Strings}
%==================================================

\begin{frame}[fragile]{Strings}
\begin{itemize}
\item Zeichenketten (engl. {\color{red} strings}) sind eine geordnete
Aneinanderreihung von Zeichen. Zeichen sind z.B. Buchstaben, Ziffern,
Sonderzeichen,...
\item Mit ihnen kann man in Sage Texte gestalten. Sie sind wichtig
für die Ausgabe der Ergebnisse.
\item Sie haben den Datentyp \isage{str}.
\item Sie werden innerhalb von Hochkommas oder Anführungszeichen angegeben.
\end{itemize}
\end{frame} 


\begin{frame}[fragile]{Beispiele für Strings}
\begin{sagein}
text1 = 'Dies ist ein String.'; text1
\end{sagein}
\begin{sage}
'Dies ist ein String.'
\end{sage}
\begin{sagein}
text2 = "Dies ist noch ein String."; text2
\end{sagein}
\begin{sage}
'Dies ist noch ein String.'
\end{sage}
\begin{sagein}
type(text1)
\end{sagein}
\begin{sage}
<type 'str'>
\end{sage}
\end{frame}

\begin{frame}[fragile]{Zugriff}
Mit dem Indexoperator {\color{blue}$[\ ]$} können einzelne Zeichen einer Zeichenkette
extrahiert werden.
\begin{sagein}
text1[0], text1[3], text1[4]
\end{sagein}
\begin{sage}
('D', 's', ' ')
\end{sage}
Ersetzungen innerhalb des Strings:
\begin{sagein}
text1.replace('Dies','Das')
\end{sagein}
\begin{sage}
'Das ist ein String.'
\end{sage}
\end{frame}

\begin{frame}[fragile]{Operationen für Strings I}
\begin{itemize}
\item Zusammenhängen von Strings
\begin{sagein}
A='Letzte '; B='Vorlesung'; A+B
\end{sagein}
\begin{sage}
'Letzte Vorlesung'
\end{sage} 
\item Ausgabe von Zeichenketten
\begin{sagein}
print(Unquoted,A.B) ??
\end{sagein}
\begin{sage}
  Letzte Vorlesung
\end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Operationen für Strings II}
\begin{itemize}
\item \isage{len} gibt die Anzahl der Zeichen in einer Zeichenkette
an.
\begin{sagein}
a=len(A+B); a
\end{sagein}
\begin{sage}
  16
\end{sage}
\begin{sagein}
(A+B)[a-1]
\end{sagein}
\begin{sage}
  'g'
\end{sage}
\item Beliebige Sage-Objekte können durch {\color{blue} \isage{str()}} in
einen String verwandelt werden.
\begin{sagein}
str(x^2+2), str([1,2,3])
\end{sagein}
\begin{sage}
('x^2 + 2', '[1, 2, 3]')
\end{sage}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Operationen für Strings III} 
\begin{itemize}
\item ??split. 
\end{itemize}
\end{frame}

% \begin{frame}[fragile]{Anwendungen}
% \item Schreiben Sie eine Funktion, die eine Zeichenkette rückwärts
% berechnet. 
% \begin{sagein}
% revers:= A->_concat(A[length(A)-i+1]
%    $\text{dollar}$ i=1..length(A))
% \end{sagein}
% \begin{sagein}
% revers("Hallo")
% \end{sagein}
% \begin{sage}
%   "ollaH"
% \end{sage}
% \end{itemize}
% \end{frame}

\section{Interaktive Elemente}

\begin{frame}[fragile]{interact}
\begin{sagein}
var('x')
x0  = 0
f   = sin(x)*e^(-x)
p   = plot(f,-1,5, thickness=2)
dot = point((x0,f(x=x0)),pointsize=80,rgbcolor=(1,0,0))
@interact
def tayl(order=(1..12)):
    ft = f.taylor(x,x0,order)
    pt = plot(ft,-1, 5, color='green', thickness=2)
    html('$f(x)\;=\;%s$'%latex(f))
    html('$\hat{f}(x;%s)\;=\;%s+\mathcal{O}(x^{%s})$'%(x0,latex(ft),order+1))
    show(dot + p + pt, ymin = -.5, ymax = 1)
\end{sagein}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Programmierung}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Größter gemeinsamer Teiler (ggT)}
Berechnung des ggT von natürlichen Zahlen $a$ und $b$ mit Hilfe des
euklidischen Algorithmus.
\bigskip

\textbf{Idee:} Es gilt:
\begin{enumerate}
 \item $ggT(a,b)=ggT(a,b-a)$ für $a<b$.
\item $ggT(a,b)=ggT(b,a)$.
\item $ggT(a,a)=a$.
\end{enumerate}

\textbf{Algorithmus:}

Wiederhole,  bis $a=b$
 \begin{itemize}
\item Ist $a>b$, so $a=a-b$.
\item Ist $a<b$, so $b=b-a$ 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Implementierung}
\begin{sage}
ggT:= proc(a,b) 
/* Bestimme den ggT von a und b */
begin
  while (a<>b) do
    if (a>b) 
         then a:=a-b;
         else b:=b-a;
    end_if;
  end_while;
  return(a);
end_proc:
\end{sage}
\end{frame}

% \begin{frame}[fragile]{Logische Ausdrücke}
% \begin{itemize}
% \item Es gibt die drei logische (Boolsche) Werte {\color{blue}\isage{TRUE}},
% {\color{blue}\isage{FALSE}} und {\color{blue}\isage{UNKNOWN}}.
% \item Sie haben den Datentyp {\color{blue}\isage{DOM_BOOL}}.
% \item Gleichungen $(=)$, Ungleichungen $(<>)$ oder Größenvergleiche 
% (\isage{<,>,<=,>=}) können durch
% \isage{bool} zu \isage{TRUE} oder \isage{FALSE} ausgewertet werden.
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[fragile]{Logische Ausdrücke}
% \begin{sagein}
% bool(3<=4)
% \end{sagein}
% \begin{sage}
%   TRUE
% \end{sage}
% \begin{sagein}
% bool(TRUE=TRUE)
% \end{sagein}
% \begin{sage}
%   TRUE
% \end{sage}
% \begin{sagein}
% bool("AS"<="B")
% \end{sagein}
% \begin{sage}
%   TRUE
% \end{sage}
% \begin{sagein}
% bool(TRUE<>UNKNOWN)
% \end{sagein}
% \begin{sage}
%   TRUE
% \end{sage}
% \end{frame}



% %-----------------------------
% \subsection{Schleifen}
% %----------------------------
% 
% \begin{frame}[fragile]{Repeat}
% Neben \isage{for} ist durch  \isage{repeat} eine weitere Schleifenvariante gegeben:
% \begin{sage}
% x:=1.1:
% repeat
%   i:=x; x:=i^2; print(i,x)
% until x>100 end_repeat:
% \end{sage}
% Die Befehle zwischen \isage{repeat} und \isage{until} werden so lange
% wiederholt, bis die Bedingung (hier $x>100$) wahr wird.
% \end{frame}
% 
% \begin{frame}[fragile]{while}
% So ähnlich wie die \isage{repeat}-Schleife funktioniert die
% \isage{while}-Schleife. 
% \begin{sage}
% x:=2:
% while x<=100 do
%  i:=x; x:=i^2; print(i,x)
% end_while:
% \end{sage}
% Die Befehle zwischen \isage{while} und \isage{end_while} werden so lange
% wiederholt, wie die Bedingung (hier $x<=100$) wahr ist.
% \end{frame}
% 
% \begin{frame}[fragile]{Verzweigung}
% \begin{itemize}
% \item Ein wichtiges Werkzeug jeder Programmiersprache sind
% Verzweigungen. 
% \item Je
% nach Wert oder Bedeutung von Variablen werden unterschiedliche Befehle
% ausgeführt. 
% \item In MuPAD gibt es das \isage{if}-Konstrukt und das \isage{case}-Konstrukt. 
% \end{itemize}
% \end{frame}

\begin{frame}[fragile]{Beispiel}
\begin{sage}
for i from 2 to 100 do
 if isprime(i)
   then print(i,"ist Primzahl")
   else print(i,"ist keine Primzahl")
 end_if
end_for:
\end{sage}
\end{frame}

\begin{frame}[fragile]{if-Konstrukt}
Die Verzweigung \isage{if} hat die folgende Struktur:
\begin{sage}
if Bedingung
    then Befehle1
    else Befehle2
end_if
\end{sage}
Ist die \isage{Bedingung} wahr, so wird \isage{Befehle1} ausgeführt,
ansonsten \isage{Befehle2}. Befehle in den Befehlsfolgen sind durch
\isage{:} oder \isage{;} zu trennen. Der \isage{else} Aufruf ist
optional. 
\end{frame}

\begin{frame}[fragile]{Berechnung von Primzahlzwillingen}
\begin{sage}
T:=[]: anz:=0:
for i from 2 to 10000 do
 if (isprime(i) and isprime(i+2))
     then anz:=anz+1;
     T:=T.[[i,i+2]];
 end_if:
end_for:
print("Anzahl = ",anz);
\end{sage}
\end{frame}

% \begin{frame}[fragile]{Case}
% Hat man eine Verzweigung mit mehreren Alternativen, so kann man
% entweder geschachtelte \isage{if} Konstrukte verwenden, oder das
% Konstrukt \isage{case} verwenden. 
% 
% \begin{sage}
% case var
%  of wert1 do ...
%  of wert2 do ...
%     ...
%  otherwise
%     ...
% end_case
% \end{sage}
% \isage{Case} funktioniert wie die \isage{switch} Anweisung in C.
% \end{frame}
% 
% \begin{frame}[fragile]{Erklärung}
% \begin{itemize}
% \item Ist keiner der \isage{of}-Zweige richtig, so wird die
%  Befehlssequenz zwischen \isage{otherwise} und \isage{end_case}
%  ausgeführt. 
% \item Durch den Befehl \isage{break} kann ein vorzeitiges Verlassen
%  der \isage{case}-Anweisung bewirkt werden.
% \item Stimmt der Wert von \isage{var} mit einem der Werte \isage{wert1},
% \isage{wert2}, \ldots,  überein, werden von dieser Stelle an alle nachfolgenden Befehle 
% ausgeführt, insbesondere also auch von \alert{allen} anderen \isage{of} und \isage{otherwise} Sequenzen). Sogenanntes {\it 'fall-through'}. 
% \end{itemize}
% \end{frame}

\begin{frame}[fragile]{Beispiel: Betrag}
\begin{sage}
betrag:=proc(a) 
     begin
       case(domtype(a))
         of DOM_INT do 
         of DOM_RAT do
         of DOM_FLOAT do
           if a>0 then y:=a: else y:=-a: end_if:
           break;
         of DOM_COMPLEX do
           y:=sqrt(Re(a)^2+Im(a)^2);
           break;
         otherwise
           print("Falscher Eingabetyp");
         end_case:
         return(y);
     end_proc:
\end{sage}
\end{frame}

\begin{frame}{Gültigkeit von Variablen I}
\begin{itemize}
\item Mit der Gültigkeit von Variablen ist die Bestandsdauer von
   Variablen bzw. der Werten dieser Variablen gemeint.
\item Beim interaktiven Gebrauch von MuPAD sind alle Variablen {\it
global}, d.h. die den Variablen zugewiesenen Werte bleiben für die
gesamte Laufzeit von MuPAD erhalten bis sie geändert werden. Man kann
auf die Variablen jederzeit zugreifen und die Werte der Variablen
ändern.
\item Daneben gibt es aber auch {\it lokale Variablen}, die nur
innerhalb einer Prozedur gültig sind. Nach Beenden der Prozedur werden
diese Variablen wieder gelöscht. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Gültigkeit von Variablen II}
\begin{itemize}
\item In MuPAD sind in Prozeduren definierte Variablen standardmäßig
\alert{global}. Die interaktiv erstellten Variablen sind sowieso
global.
\item Mit dem Schlüsselwort \isage{local} können in Prozeduren lokale 
Variablen erzeugt werden. \isage{local} steht zwischen \isage{proc()}
und \isage{begin}.
\item Die lokalen Bezeichner sind vom Typ \isage{DOM_VAR} (nicht wie
erwartet \isage{DOM_IDENT}).  
\item Die Input-Argumente von Prozeduren sind lokale Variablen.
\end{itemize}
\end{frame}

% \begin{frame}{Goldene Regel}
% \begin{huge}
% \begin{block}{}
%  Die Verwendung von globalen Variablen in Prozeduren ist
% schlechter Programmierstil und sollte vermieden werden.
% \end{block}
% \end{huge}
% \end{frame}

% \begin{frame}[fragile]{Beispiele}
% Ein Beispiel mit globalen Variablen
% \begin{sagein}
% a:=b: 
% f:=proc() 
%       begin 
%         a:=1+a^2: 
%       end_proc:
% f(); f(); f()
% \end{sagein}
%  Ein Beispiel mit lokalen Variablen
% \begin{sagein}
% a:=b: 
% f:=proc() 
%       local a; 
%         begin a:=2 
%       end_proc:
% f(); a
% \end{sagein}
% \end{frame}


\begin{frame}[fragile]{Rekursives Beispiel}
Berechnung der Fakultät einer natürlichen Zahl
\begin{sage}
/* Berechnung der Fakultaet */
fakultaet := proc(n) begin
       if domtype(n)=DOM_INT and n>0
           then 
              if n=1 then return(1)
              else n*fakultaet(n-1)
              end_if
            else 
              print("Falscher Datentyp");
            end_if
end_proc:
\end{sage}
\end{frame}

\begin{frame}[fragile]{Symbolische Rückgabe}
\begin{sagein}
fakultaet(9)
\end{sagein}
\begin{sage}
  362880
\end{sage}
\begin{sagein}
x!
\end{sagein}
\begin{sage}
  fact(x)
\end{sage}
\begin{sagein}
fakultaet(x)
\end{sagein}
\begin{sage}
  "Falscher Datentyp"
\end{sage}
\begin{itemize}
\item Viele Systemfunktionen wie \isage{fact}, geben den Prozeduraufruf
               symbolisch zurück, wenn er nicht auszuwerten ist.
\item Die Auswertung kann dann später erfolgen.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Fakultät II}
\begin{sage}
/* Berechnung der Fakultaet */
fakultaet2 := proc(n) 
  begin
       if testtype(n,Type::PosInt)
           then 
              if n=1 then return(1)
              else n*fakultaet2(n-1)
              end_if
            else 
              return(procname(args()));
            end_if
  end_proc:
\end{sage}
\end{frame}

\begin{frame}[fragile]{Erklärungen}
\begin{itemize}
\item Durch \isage{args()} erhält man die Folge der Argumente. 
\item \isage{args(0)} ist die Anzahl der Argumente.
\item Durch \isage{args(i)} erhält man das $i$-te Element.
\item Mit diesen Befehlen kann man Prozeduren mit einer beliebigen
Anzahl von Argumenten programmieren.
\item \isage{procname} ist der Name der Prozedur.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Testen des Typs}
Durch den Aufruf
\begin{sage}
testtype(Objekt, Typenbezeichner)
\end{sage}
wird getestet, ob ein \isage{Objekt} dem Typenbezeichner
entspricht. Rückgabewert ist \isage{TRUE} oder \isage{FALSE}.
\begin{itemize}
\item Prinzipiell kann man auch \isage{domtype} zum Überprüfen des Typs
benutzen. 
\item Die Typenbezeichner sind aber differenzierter.
\item Übersicht der verfügbaren Typenbezeichner erhält man durch
{\color{blue} \isage{? Type}}. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Beispiele}
\begin{sagein}
testtype(sqrt(3),Type::Real)
\end{sagein}
\begin{sage}
  FALSE
\end{sage}
\begin{sagein}
testtype(float(sqrt(3)),Type::Real)
\end{sagein}
\begin{sage}
  TRUE
\end{sage}
\begin{sagein}
testtype(3,Type::Real)
\end{sagein}
\begin{sage}
  TRUE 
\end{sage}
\begin{sagein}
select([i $\text{dollar}$ i=100..120],testtype,Type::Prime)
\end{sagein}
\begin{sage}
  [101, 103, 107, 109, 113]
\end{sage} 
\end{frame}


\begin{frame}[fragile]{Mandelbrot-Menge}
Die Mandelbrot-Menge ist die Menge von Punkten $c \in \mathbb{C}$
bei denen die Folge $(z_n)_n$, die durch
\[ z_0:=c, \qquad  z_{n+1} = z_n^2 +c, \quad n \in \mathbb{N}\]
definiert ist, beschränkt ist.
\end{frame}

\begin{frame}[fragile]{Programm - Mandelbrot}
\begin{small}
\begin{sage}
mandel:=proc(x,y)
  local it,a0,a,MAX_IT;
  begin
    if not (testtype(x,Type::Real) and 
           testtype(x,Type::Real))
     then procname(x,y)
    else
      MAX_IT := 150;
      it := 0;
      a0 := x + I*y;
      a := a0;
      while (abs(a)<2 and it<MAX_IT) do
        a := a^2 + a0;
        it := it + 1;
      end_while;
      return(float(it/MAX_IT));
    end_if;
  end_proc:
\end{sage}
\end{small}
\end{frame}

\begin{frame}[fragile]{Plot - Mandelbrot}
Die Funktion \isage{mandel} gibt zu $x+iy$ die relative Anzahl der
Iterationsschritte zurück.\\

Geplottet wird die Funktion nun wie folgt:
 
\begin{sage}
PlotteMandel:=proc()
  begin
    mandelPlot:=plot::Function3d(mandel(x,y),
      x=-2.1..1.2, y=-1.1..1.1, Mesh=[100,100]);
    plot(mandelPlot,Width=20*unit::cm, 
      Height=15*unit::cm);
  end_proc:
\end{sage}
\end{frame}

\begin{frame}[fragile]{Programmierregeln}
\begin{itemize}
\item Falls möglich, nur lokale Variablen benutzen.
\item Programme vollständig kommentieren. Das heißt zum einen das eine
Kommentarzeile zu Beginn steht, was das Programm macht und wieviele
und welche Eingabeparameter es erhalten darf und was die Prozedur
zurückgibt. Zusätzlich sollten auch alle wesentlichen Operationen
kommentiert werden.
\item Werte explizit mit \isage{return()} zürückgeben.
\item Programme übersichtlich gestalten, z.B. Schleifen oder
Verzweigungen einrücken.
\item Keine Umlaute in Programmkommentaren verwenden.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Letztes Beispiel I}
\begin{sage}
Gadisch:=proc(x,basis)
  /*---------------------------------------
   Berechnung der  Darstellung
   einer natuerlichen Zahl x zur Basis b
   Rueckgabe des Ergebnis als Liste! 
  -----------------------------------------*/
  local T,T_r,i;  /* lokale Variablen*/
  begin /* Beginn lokale Prozedur */
  /* Abfangen der Eingabe */
    if not testtype(x,Type::PosInt) 
       then return(procname(args()));
    end_if;
    if (not testtype(basis,Type::PosInt)) or basis=1
       then return(procname(args()));
    end_if;  
\end{sage}
\end{frame}

\begin{frame}[fragile]{Letztes Beispiel II}
\begin{sage}
    T:=[];  /* leere Liste */ 
    /* Beginn Schleife */
    while x>0 do  
      T:=[x mod basis].T;
      print(Unquoted,expr2text(x)." : "
        .expr2text(basis)." = "
        .expr2text(x div basis)." Rest "
        .expr2text(x mod basis));
      x:=(x div basis);
    end_while;
    /* Rueckgabe der Liste */
    return(T);
  end_proc:  
\end{sage}
\end{frame}

\begin{frame}{Allerletztes Beispiel: Kochsche Kurven I}
\begin{itemize}
\item Seien $y_1,y_2$ zwei Punkte im $\mathbb{R}^2$. 
\item Betrachte die Strecke mit Endpunkten $y_1$ und $y_2$.  
\item Ersetze  diese Strecke durch 4 Strecken 
$\overline{y_1 z_1}$, $\overline{z_1 z_2}$, $\overline{z_2 z_3}$,
$\overline{z_3 y_2}$ mit Endpunkten 
\begin{eqnarray*}
 z_1 &=\frac23 y_1 + \frac13 y_2\\[0.5cm]
 z_2 &= \frac{\sqrt{3}}{6} \left( \begin{array}{cc}
 0 & 1 \\ -1 & 0 \\
 \end{array} \right)
 (y_1 - y_2) + \frac12 (y_1 + y_2)\\[0.5cm]
 z_3 &=\frac13 y_1 + \frac23 y_2
\end{eqnarray*}
\item Dieses Prozedere wird nun für jede einzelne Teilstrecke wiederholt.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Allerletztes Beispiel II}
\begin{sage}
koch:=proc(y1,y2,lev)
  local z1,z2,z3;
  begin
    if (lev = 0)
      then Listelinien:=append(Listelinien,
        plot::Line2d([y1[1],y1[2]],[y2[1],y2[2]]));
    else
      /* Definieren der neuen Punkte */
      z1 := 2/3 * y1 + 1/3 * y2;
      z3 := 1/3 * y1 + 2/3 * y2;
      z2 := sqrt(3)/6*matrix([[0, 1],[ -1, 0]])*
              (y1-y2) + 1/2 * ( y1 + y2);
      /* Definieren der 4 Strecken */
      koch(y1, z1, lev-1);
      koch(z1, z2, lev-1);
      koch(z2, z3, lev-1);
      koch(z3, y2, lev-1);
    end_if;
  end_proc:
\end{sage}
\end{frame}

\begin{frame}[fragile]{Allerletztes Beispiel III}
\begin{sage}
/* Einfacher Fall einer Linie */
plotKoch1:=proc(lev)
           begin
             Listelinien := [];
             y1 := matrix([0,0]);
             y2 := matrix([1,0]);
             koch(y1,y2,lev);
             plot(Listelinien, Axes = None);
           end_proc:
\end{sage}
\end{frame}
\end{document}
