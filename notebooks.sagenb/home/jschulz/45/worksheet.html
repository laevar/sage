

<h2>Aufgabe 1</h2>

{{{id=54|
tuple1 = (2,3)
print tuple1+(4,), tuple1[1]
liste1 = [2,3]
print liste1+[4], liste1[1]
var('i1,i2,i3')
dictionary1 = {i1:2,i2:3}
dictionary1[i3]=4,dictionary1[i1]
print dictionary1
Menge1 = Set([2,3])
print Menge1[1], Menge1.union(Set([4]))
///
(2, 3, 4) 3
[2, 3, 4] 3
{i1: 2, i3: (4, 2), i2: 3}
3 {2, 3, 4}
}}}

<h2>Aufgabe 2</h2>

{{{id=59|
expr=x^2
simplify(x^2)
expr.full_simplify()
expr.simplify_trig()
expr.expand()
expr.factor()
///
x^2
}}}

{{{id=63|
expr = x*(x+1)+x/(2+x)
print expr.expand()
print expr.simplify()
print expr.factor()
print expr.partial_fraction()
///
}}}

<h2>Aufgabe 3</h2>

{{{id=61|
for i in [2..5]:
    print i,i^2
///
2 4
3 9
4 16
5 25
}}}

<h2>Aufgabe 4</h2>

{{{id=1|
def f(n): return 2^(2^n)+1
///
}}}

{{{id=34|
type(f),f,f(2)
///
(<type 'function'>, <function f at 0xab99294>, 17)
}}}

{{{id=31|
f(n) = 2^(2^n)+1
///
}}}

{{{id=33|
type(f),f,f(2)
///
(<type 'sage.symbolic.expression.Expression'>, n |--> 2^(2^n) + 1, 17)
}}}

<p>Bei der def-Funktion wird erst mit uebergebenen Wert ausgewertet . Bei der Expression werden bereits vorher die Rechte seite ausgewertet.</p>

<h2>Aufgabe 5</h2>
<p>&nbsp;</p>

{{{id=65|
def rechner(a):
    s = 0
    for x in a.split("+"):
        p = 1
        for y in x.split("*"):
            p = p * int(y)
        s = s + p
    return s
///
}}}

{{{id=66|
rechner("2+3*4+8")
///
22
}}}

<h2>Aufgabe 6</h2>

{{{id=62|
def prog(n):
    z = 1
    k = 1
    x=[]
    while True:
        if is_prime(z)==True:
            x.append(z)
            k+=1
        if  k >= n: break
        z += 1
    return x,k
prog(10)
///
([2, 3, 5, 7, 11, 13, 17, 19, 23], 10)
}}}

<h2></h2>

<h2></h2>

<h2></h2>

<h2>moegliche aufgaben</h2>
<p>eine for-schleife wiederholt eine abfolge von befehlen fuer jedes element aus einer gegebenen liste, wobei das jeweilige element innerhalb der schleife genutzt werden kann.</p>

{{{id=48|
f(x) = exp(x)
a = srange(0,1,.1)
TOL = .1
finish = false
while not finish:
    finish = true
    b = []
    for i in [0..len(a)-2]:
        if abs(f(a[i])-f(a[i+1])) > TOL:
            b.append(a[i])
            b.append((a[i]+a[i+1])/2)
            finish = false
        else:
            b.append(a[i])
    b.append(a[len(a)-1])
    a = b
///
}}}

{{{id=52|

///
}}}